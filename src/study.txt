


17. Точка входа в приложение --> ReactDOM.render(<App />, document.getElementById('root'));
17. root находится в index.html в папке public.
18. Компонента - это функция которая возвращает JSX и принимает параметр props.
19. Route устанавливается таким образом --> npm install react-router-dom -save. (чтобы сам дополнял  package.json файл).
<Route path='/news' render={() => <Dialogs />}  --> следит за URL если он совпадает рендерит страницу.
19. <BrowserRouter> покрывет все роуты, и для каждого роута надо указать путь таким образом --> <Route path='/news' component={News}/>
20. Для перехода на др пункты не будем обновлять страницу. Это делаем с помощью <NavLink to='/music'>Music<NavLink>
22. Путь должке являться под путем, Route следит за этим. Например: <NavLink to={/dialogs/1}>Link</NavLink>  dialogs является главный
путем, а 1 находится под путем.
23. UI(React) + BLL(Business Logic Layer)(Redux - наши данные).
25. Метод map позволяет применить заданную функцию для каждого элемента массива. При этом метод не изменяет
исходный массив, а возвращает измененный.

СИНТАКСИС:
let новый массив = массив.map(function(элемент, индекс, массив) {
	код
	return измененный элемент;
})

ПРИМЕР-2:
let arr = [1, 2, 3, 4, 5];

let result = arr.map(function(elem) {
	return elem * 2;
});
console.log(result);
Результат выполнения кода:
[2, 4, 5, 8, 10]

ПРИМЕР-2:
let arr = [1, 2, 3, 4, 5];

let result = arr.map(function(elem, index) {
	return elem * index;
});
console.log(result);
Результат выполнения кода (первый элемент: 1*0, второй: 2*1, третий: 3*2, четвертый: 4*3, пятый: 5*4):
[0, 2, 6, 12, 20]

ПРИМЕР-3:
let arr = [1, 2, 3, 4, 5];
let result = arr.map(function(elem, index, arr) {
	тут будет доступен массив arr
});

27. UI отвечает на отрисовку страницы с помощью Реакт. BLL это типа  хранилище где хранятся  данные , какие-то функции и методы.
BLL это и есть Redux.
28. Props это объект который передается во время отрисовки компонента. Анонимная функция - { () => {<Dialogs/} }.
Чтобы вынести данные на index.jsx, используем для передачи объектов props. Например данные находнять в index.jsx,
будем передавать таким путем --> <App posts={posts}/>   -->    <Route path='/account' render={() => <Account posts={props.posts}/>}/>  --->
-->   <MyPosts posts={props.posts}/>     <-- здесь получаем данные с объекта 'props", обрабатывем и отрисуем их.
31. Когда мы сами не вызиваем функцию, а отдаем ее кому-то чтобы ее кто-то другой вызвал это функция называется - CALLBACK функцией.
document.getElementById('example').value   -->   для получения значение по идишнику.
Рефы дают возможность получить доступ к DOM-узлам или React-элементам, созданным в рендер-методе. let newElem = React.createRef();
Когда реф передаётся элементу в методе render, ссылка на данный узел доступна через свойство рефа current.
32. прокидываем callback через props
state - Компонент нуждается в state, когда данные в нём со временем изменяются. Например, компоненту Checkbox может понадобиться
состояние isChecked, а компоненту NewsFeed необходимо отслеживать посты при помощи состояния fetchedPosts. Самая большая разница
между state и props состоит в том, что props передаются от родителя потомку, а state управляется самим компонентом. Компонент
не может изменять props, но может изменять state.
35. Инкапсуляция - скрыть детали.
39. Action это объект, у которого минимум есть свойство 'type'.
40. Reducer это функция, которая принимает action или state, и возвращает new state.
42. REDUX установка --> install npm redux.
| initialState --> store (store это хранилище, он умеет возвращать текущий state, умеет вызивать какие-то действия и
позволяет подписаться на изменение состояния).
| view --> action --> reducer(state, action) --> newState   (например у нас есть какая-то кнопка, мы нажимаем кнопку и срабативает
какое-то событие(action). Обработкой экшнов занимаются такие функции reducer(). Reducer всегда возвращает новый объект state,
принимает два параметра: текущее состояние state и действие action которое было вызвано).
43. container component (контейнерная компонента) - компонента не должна знать о данных откуда они приходят откуда берем их.
Потому что они тупые они берут и просто отрисовывают нам компоненту.
44. Context API - Контекст позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных
уровнях. Для этого мы создаем наш контекст  -->  const MyContext = React.createContext(defaultValue). Потом посадим нашего доставщика
во внутр APP.JS  -->
<MyContext.Provider value={store}>
    <App/>
</MyContext.Provider>
 и  передаем черех него наш Store по всему приложению. Как получить данные
в компонентах? Очень просто, для этого существует Consumer то есть получатель потребитель. -->
<MyContext.Consumer>
    {(store) => ()}
</MyContext.Consumer>
46. Используем элементы Spread (…) (Или оператор расширения) для копирования объектов.......
let svetr = {size: 'S', color: 'white'}
let svetrCopy = {...svetr};
51. REST Representational State Transfer — «передача состояния представления»
52. AXIOS - это широко известная JavaScript-библиотека. Она представляет собой HTTP-клиент, основанный на промисах и предназначенный
для браузеров и для Node.js.
npm install axios --save
53. SIDE EFFECT - нельзя делать в внутри компонентах --> api calls, modification of paramaetrs, change DOM directly,
change outer scope variables.
54. Для чего нужны классы? Для того чтобы создавать однотипные объекты на базе этих классов. + ООП(Абстракция, Инкапсуляция, Полиморфизм
и Наследование).
Жизненный цикл - LIKE CYCLE METHODS...